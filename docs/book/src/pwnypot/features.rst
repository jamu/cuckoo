========
Features
========

The main features of PwnyPot are:

* :ref:`general_protections`
* :ref:`shellcode_detection`
* :ref:`shellcode_dumps`
* :ref:`dynamic_analysis`
* :ref:`rop_detection`
* :ref:`rop_gadgets`
* :ref:`bypass_detection`

.. _general_protections:

General Protections
===================
  The following protections can be enabled with PwnyPot:

    * Null Page Allocation

      Null Page Allocation is prevented by allocation the Null Page before anything else does it in the thread. 


    * Heap Spray Mitigation

      Pwnypot tries to mitigate Heap Sprays by allocating common Heap Spray addresses.

    
    * Structured Exception Handler Overwrite Protection (SEHOP)

      In order to get the execution flow of the program to injected code, an attacker can use the SEH overwrite technique. For more details of this attack see (http://blogs.technet.com/b/srd/archive/2009/02/02/preventing-the-exploitation-of-seh-overwrites-with-sehop.aspx).
      With Windows Vista SP1 and above SEHOP is already provided and can be enabled per Process. With the configuration variable sehop set to 1, SEHOP is enabled for the analyzed process. 
      Pwnypot checks whether native SEHOP is possible, otherwise uses its own implementation. With force_pwnypot_sehop set to 1, the pwnypot implementation is used even if native SEHOP is supported. This is useful to analyze the attack on the Exception Chain. 

      The SEHOP implementation of PwnyPot is done by validating the Exception Chain before any Exception Handler is called. Therefore, the prologue of KiUserExceptionDispatcher is overwritten with a jump to the validation function. The exception chain is then validated, by walking through it and also by validating the corresponding exception handlers. If no malicious codes can be found, the overwritten prologue and a jump to the position afterwards is executed.
      More details can be found here (http://www.uninformed.org/?v=5&a=2&t=txt).


.. _shellcode_detection:

Shellcode Detection by doing Export Address Table Validation
============================================================
  

.. _shellcode_dumps:

Shellcode Dumps
===============

  On detection of shellcode, PwnyPot will dump the shellcode in binary and disassembled format. 

.. _dynamic_analysis:

Dynamic Shellcode Analysis with API Hooks
=========================================

  When PwnyPot detects the execution of shellcode and malware execution is enabled in the configuration file, multiple Windows API functions are Hooked to monitor the activities of the shellcode. For all these functions we write all parameters to the analysis output. The following functions are hooked:

    * CreateProcessInternalW

    * URLDownloadToFileW

    * LoadLibraryExW

    * socket

    * connect 

    * listen

    * bind

    * accept

    * send

    * recv

.. _rop_detection:

ROP Detection
===============
  Pwnypot tries to detect Return-oriented Programming Exploits by hooking the following functions and analyzing ther parameters:

    * VirtualAlloc
    * VirtualProtect
    * VirtualAllocEx
    * VirtualProtectEx
    * MapViewOfFile
    * MapViewOfFileEx
    * HeapCreate

  Each of this hooks is calling a function implemented in Assembly in order to analyze the stack pointer. Before the real unhooked function is called, the function RopDetection.cpp:ValidateCallAgainstRop is called. This function takes care, that the stack pointer is pointing to a valid address between the stack boundaries of the thread. 

  If the configuration parameter stack_rwx is set to 1, it is also checked, that the stack does not get changed to be executable.

  Whenever PwnyPots validates a call as a ROP attack, it marks the thread with a ROP flag, so that other parts of PwnyPot can react accordingly.

  Further methods to analyze the above function calls are going to be implemented in the future: forward execution, stack pivoting detection and call validations.

.. _rop_gadgets:

ROP Gadget Dumps
================
  PwnyPot dumps the gadgets that it found during an analysis when the configuration parameter dump_rop is set to 1. The dumps contain the module name, the instructions and also references to memory address outside of the module address space.

  The dump is generated by reading consecutive addresses following the ESP when a function call has been identified as a part of a ROP chain.

  Example output::

    Module:    C:\Program Files\Java\jre6\bin\MSVCR71.dll

      Gadget @ Offset 0x00024C66  
        7c364c66 (01) 5d                       POP EBP
        7c364c67 (01) c3                       RET

      Addresses outside of the Module 
        [ 0x0C0C0C58 ]        DB  0x0C0C0C6C        ...l
        [ 0x0C0C0C5C ]        DB  0x00000401        ....
        [ 0x0C0C0C60 ]        DB  0x00000040        ...@




.. _bypass_detection:

Detection of ASLR/DEP Bypasses
==============================
  ROP chains are often used to call Windows APIs to circumvent DEP or ASLR. With DEP disabled injection of shellcode is easier, because most parts of the memory are marked as writable but not executable or not writable but executable. Most of the functions will fail in an exploit, if Permanent DEP is enabled. Nevertheless PwnyPot detects these methods, because older Windows Versions (up to Win XP) do not have permanent DEP enabled by Default. Furthermore it gives a more complete view of used methods of the malware. 
  The following APIs are Hooked by PwnyPot to detect possible DEP and ASLR bypasses:
    
    * BOOL WINAPI SetProcessDEPPolicy (DWORD dwFlags)
        This is the most trivial, but also probably least working method for an attacker to disable DEP. It fails, if permanent DEP is enabled and the function does not even exist anymore in Windows Versions after Windows XP. The value of dwFlags must be 0 in order to disable DEP.

    * NTSTATUS WINAPI NtSetInformationProcess (HANDLE hProcess, ULONG ProcessInformationClass, __in_bcount(ProcessInformationLength)PVOID ProcessInformation, ULONG ProcessInformationLength)
        This WINNT function can be used to change the DEP Policy of a Process. Therefore the ProcessInformationClass must be set to 0x22 which stands for setting the ProcessExecuteFlags. ProcessInformation then contains the Information which Execute Flags should be set. PwnyPots detects, if this value contains the flag to enable memory execution. This is eequivalent to disabling DEP. 


    * NTSTATUS NTAPI WriteProcessMemory (__in        HANDLE hProcess, __in      LPVOID lpBaseAddress, __in        LPCVOID lpBuffer, __in      SIZE_T nSize,  __out   SIZE_T \*lpNumberOfBytesWritten )
        This API function allows to write to a given memory address inside the process address space. Even if the page the address belongs to is marked as executable and not writable, this function can write. Internally it sets the correct flags (writable) to the corresponding page. This is extremely dangerous when the process has loaded DLLs which dont have ASLR enabled. One way to exploit this function is to overwrite the memory direct after the address of WriteProcessMemory itself inside KERNEL32.DLL, because this DLL has no ASLR enabled and is loaded into nearly any Windows process. PwnyPot protects against this type of WPM calls and reports also other calls.

    * VOID NTAPI LdrHotPatchRoutine ( PVOID * HotPatchBuffer)
        In each Windows 32-bit application on a Windows 64 bit system a fixed memory region at address 0x7ffe0000 exists, called SharedUserData. This memory region holds multiple function pointers, also to a function called LdrHotPatchRoutine. This function gets a pointer to a struct as a parameter and loads code (e.g. a DLL) from a given UNC path inside this struct. By using this function an attacker does not have to deal with ASRL.
        Each call to this function gets logged and also analyzed for unusual behaviour (like loading a DLL from network).

        

